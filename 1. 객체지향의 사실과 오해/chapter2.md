# 2장. 이상한 나라의 객체
## 2-1. 객체지향과 인지 능력
- 객체지향 패러다임은 인간이 인지할 수 있는 다양한 객체들이 모여 현실 세계를 이루는 것처럼 소프트웨어의 세계 역시 인간이 인지할 수 있는 다양한 소프트웨어 객체들이 모여 이뤄져 있다는 믿음에서 출발한다. 그러나 객체지향 패러다임의 목적은 현실 세계를 모방하는 것이 아니라 현실 세계를 기반으로 **새로운 세계를 창조**하는 것이다. 

## 2-2. 객체, 그리고 이상한 나라
### 2-2-1. 이상한 나라의 앨리스

### 2-2-2. 앨리스 객체
- 어떤 행동의 성공 여부는 이전에 어떤 행동들이 발생했는지에 영향을 받는다. 또한, 행동 간의 순서가 중요하다.
- **앨리스의 특징**
    - 앨리스는 상태를 가지며 상태는 변경 가능하다.
    - 앨리스의 상태를 변경시키는 것은 앨리스의 행동이다.
        - 행동의 결과는 상태에 의존적이며 상태를 이용해 서술할 수 있다.
        - 행동의 순서가 결과에 영향을 미친다.
    - 앨리스는 어떤 상태에 있더라도 유일하게 식별 가능하다.

## 2-3. 객체, 그리고 소프트웨어 나라
- 이 책에서 정의하는 객체: 객체란 **식별 가능한 개체 또는 사물**이다. 객체는 구별 가능한 식별자, 특징적인 행동, 변경 가능한 상태를 가진다. 소프트웨어 안에서 객체는 저장된 상태와 실행 가능한 코드를 통해 구현된다. 

객체의 관점에서 상태, 행동, 식별자의 개념을 정리해보자.

### 2-3-1. 상태
#### 왜 상태가 필요한가
- 객체가 주변 환경과의 상호작용에 어떻게 반응하는가는 **그 시점까지 객체에 어떤 일이 발생했느냐**에 좌우된다. 그러나 과거에 발생한 행동의 이력을 통해 현재 발생한 행동의 결과를 판단하는 방식은 복잡하고 번거로우며 이해하기 어렵다. 따라서 **상태**라는 개념을 고안했다.
- 상태를 이용하면 과거에 얽매이지 않고 현재를 기반으로 객체의 행동 방식을 이해할 수 있다.

#### 상태와 프로퍼티
- 단순한 값들(숫자, 문자열, 양, 속도, 시간, 날짜, 참/거짓 등)은 그 자체로 독립적인 의미를 가지기보다는 다른 객체의 특성을 표현하는 데 사용된다. 
- **모든 객체의 상태는 단순한 값과 객체의 조합**으로 표현할 수 있다. 
- 프로퍼티(property) : 객체의 상태를 구성하는 모든 특징
    - 프로퍼티는 변경되지 않고 고정되기 때문에 '정적'이다.
    - 프로퍼티 값(property value)는 시간이 흐름에 따라 변경되기 때문에 '동적'이다.  
    - 프로퍼티는 속성과 링크 두 가지 종류의 조합으로 표현할 수 있다.
        - 링크(link) : 객체와 객체 사이의 의미 있는 연결
            - 객체의 링크를 통해서만 메시지를 주고받을 수 있다. 즉, 링크는 객체가 다른 객체를 참조할 수 있다는 것을 의미한다.
        - 속성(attribute) : 객체를 구성하는 단순한 값

- 이 책에서 정의하는 상태: 상태는 **특정 시점에 객체가 가지고 있는 정보의 집합**으로 객체의 구조적 특징을 표현한다. 객체의 상태는 객체에 존재하는 정적인 프로퍼티와 동적인 프로퍼티 값으로 구성된다. 객체의 프로퍼티는 단순한 값과 다른 객체를 참조하는 링크로 구분할 수 있다. 
- 객체는 자율적이며, 자율적이기 때문에 스스로 자신의 상태를 책임져야 한다. 외부의 객체가 객체의 상태를 변경하고 싶다면 행동을 통해 다른 객체로 하여금 간접적으로 객체의 상태를 변경할 수 있도록 한다.

### 2-3-2. 행동
#### 상태와 행동
- 객체가 취하는 행동은 객체 자신의 상태를 변경시키며, 이는 행동이 **부수 효과(side effect)**를 초래한다는 것을 의미한다.
- 객체의 행동은 객체의 상태를 변경시키지만 행동의 결과는 객체의 상태에 의존적이다. 
- **상태와 행동 사이의 관계**
    - 객체의 행동은 상태에 영향을 받는다 👉 상호작용이 현재의 상태에 어떤 방식으로 의존하는가
    - 객체의 행동은 상태를 변경시킨다 👉 상호작용이 어떻게 현재의 상태를 변경시키는가

#### 협력과 행동
- 객체가 다른 객체와 협력하는 유일한 방법은 다른 객체에게 요청을 보내는 것이며, 메시지를 통해 이러한 협력이 이루어진다.
- 객체는 협력에 참여하는 과정에서 자기 자신의 상태뿐만 아니라 다른 객체의 상태 변경을 유발할 수도 있다.
- **객체의 행동으로 인해 발생하는 부수효과를 설명하는 두 가지 관점**
    - 객체 자신의 상태 변경
    - 행동 내에서 협력하는 다른 객체에 대한 메시지 전송
- 이 책에서 정의하는 행동: 행동이란 **외부의 요청 또는 수신된 메시지에 응답하기 위해 동작하고 반응하는 활동**이다. 행동의 결과로 객체는 자신의 상태를 변경하거나 다른 객체에게 메시지를 전달할 수 있다. 객체는 행동을 통해 다른 객체와의 협력에 참여하므로 행동은 외부에 가시적이어야 한다. 

#### 상태 캡슐화
- 캡슐화: 객체는 상태를 캡슐 안에 감춰둔 채 외부로 노출하지 않고 행동만을 외부에 노출하며, 외부에서 객체에 접근할 수 있는 유일한 방법 역시 행동 뿐이다.
    - 상태를 잘 정의된 행동 집합 뒤로 캡슐화하는 것은 **객체의 자율성을 높이고 협력을 단순하고 유연하게** 만든다.

### 2-3-3. 식별자
- 모든 객체는 식별자를 가지며 식별자를 이용해 객체를 구별할 수 있다.
- 식별자 : 객체 안에 존재하는, 객체를 서로 구별할 수 있는 특정한 프로퍼티
- 값은 변하지 않는 양을 모델링한다. 값의 경우 두 인스턴스의 상태가 같다면 두 인스턴스를 같은 것으로 판단한다. 값이 같은지 여부는 상태가 같은지를 이용해 판단한다. 이처럼 상태를 이용해 두 값이 같은지 판단할 수 있는 성질을 **동등성**(equality)이라고 한다. 값은 오직 상태만을 이용해 두 값이 같은지 판단할 수 있기 때문에 별도의 식별자를 필요로 하지 않는다.
- 객체는 시간에 따라 변경되는 상태를 포함하며, 행동을 통해 상태를 변경한다. 두 객체를 같은 객체로 판단할 수 있는지는 식별자를 사용하며, 식별자를 기반으로 객체가 같은지를 판단할 수 있는 성질을 **동일성**(identical)이라고 한다.
- 값은 상태가 변하지 않기 때문에 상태로 동등성을 판단할 수 있지만, 객체는 시간이 흐름에 따라 상태가 변하기 때문에 상태 변경에 독립적인 별도의 식별자로 판단해야 한다.
- 이 책에서 정의하는 식별자 : 식별자란 **어떤 객체를 다른 객체와 구분하는 데 사용하는 객체의 프로퍼티**다. 값은 식별자를 가지지 않기 때문에 상태를 이용한 동등성 검사를 통해 두 인스턴스를 비교해야 한다. 객체는 상태가 변경될 수 있기 때문에 식별자를 이용한 동일성 검사를 통해 두 인스턴스를 비교할 수 있다.
- 대부분의 객체지향 프로그래밍 언어에서 두 개념 모두 클래스를 이용해 구현되기 때문에 별도의 용어를 사용하기도 한다.
    - 참조 객체(reference object), 엔티티(entity): 식별자를 지닌 전통적인 의미의 객체를 가리키는 용어
    - 값 객체(value object): 식별자를 가지지 않는 값을 가리키는 용어

### 요약
- 객체는 상태를 가지며 상태는 변경 가능하다
- 객체의 상태를 변경시키는 것은 객체의 행동이다.
    - 행동의 결과는 상태에 의존적이며 상태를 이용해 서술할 수 있다.
    - 행동의 순서가 실행 결과에 영향을 미친다.
- 객체는 어떤 상태에 있더라도 유일하게 식별 가능하다.

## 2-4. 기계로서의 객체
- 객체가 외부에 제공하는 행동의 대부분은 쿼리와 명령으로 구성된다.
    - 쿼리(query): 객체의 상태를 조회하는 작업
    - 명령(command): 객체의 상태를 변경하는 작업
- 사용자는 객체가 제공하는 행동인 명령과 쿼리로 구성된 인터페이스를 통해서만 객체에 접근할 수 있다.

## 2-5. 행동이 상태를 결정한다
- 상태를 먼저 결정하고 행동을 나중에 결정하는 방법은 설계에 나쁜 영향을 끼친다.
    1. 상태를 먼저 결정할 경우 캡슐화가 저해된다.
    2. 객체를 협력자가 아닌 고립된 섬으로 만든다.
    3. 객체의 재사용성이 저하된다.
- 객체는 다른 객체와 협력하기 위해 존재하며, 객체의 행동은 객체가 협력에 참여하는 유일한 방법이다. 즉, 객체지향 설계에서 애플리케이션에 필요한 **협력을 생각**하고 협력에 참여하는 데 **필요한 행동을 생각**한 후 행동을 수행할 **객체를 선택**하는 식으로 해야 한다.
- 협력 안에서 객체의 행동은 결국 객체가 협력에 참여하면서 완수해야 하는 책임을 의미한다. 따라서 어떤 책임이 필요한가를 결정하는 과정이 전체 설계를 주도해야 한다. 이 책에서 살펴볼 **책임-주도 설계**(Resonsibility-Driven Design, RDD)는 협력이라는 문맥 안에서 객체의 행동을 생각하도록 도움으로써 응집도 높고 재사용 가능한 객체를 만들 수 있게 한다.
- **행동이 상태를 결정한다.**

## 2-6. 은유와 객체
### 2-6-1. 두 번째 도시전설
- 일반적으로 알고 있는 것과 달리, 객체지향 세계는 현실 세계와 전혀 다른 양상을 띤다. 
- 모방과 추상화라는 개념만으로는 현실 객체와 소프트웨어 객체 사이의 관계를 깔끔하게 설명하지 못한다.

### 2-6-2. 의인화
- 현실 속의 객체와 소프트웨어 객체 사이의 가장 큰 차이점: 현실 속에서는 수동적인 존재가 소프트웨어 객체로 구현될 때는 **능동적으로 변한다.**
- 의인화(anthropomorphism): 현실의 객체보다 더 많은 일을 할 수 있는 소프트웨어 객체의 특징
    - 의인화의 관점에서 소프트웨어를 생물로 생각하자. 모든 생물처럼 소프트웨어는 태어나고, 삶을 영위하고, 그리고 죽는다.

### 2-6-3. 은유
- 은유: 실제로는 적용되지 않는 한 가지 개념을 이용해 다른 개념을 서술하는 대화의 한 형태
- 현실 속의 객체의 의미 일부가 소프트웨어 객체로 전달되기 때문에 프로그램 내의 객체는 현실 속의 객체에 대한 은유다.
- 소프트웨어 객체에 대한 현실 객체의 은유를 효과적으로 상용할 경우 이해하기 쉽고 유지보수가 용이한 소프트웨어를 만들 수 있다. 👉 현실 세계인 도메인에서 사용되는 이름을 객체에게 부여하라.

### 2-6-4. 이상한 나라를 창조하라.
- 객체지향 설계자로서 우리의 목적은 현실을 모방하는 것이 아니라, **새로운 세계를 창조**하는 것이다.
    - 만약 창조한 객체의 특성을 상기시킬 수 있다면 현실 속의 객체의 이름을 이용해 객체를 묘사해도 좋지만, 그렇지 않다면 깔끔하게 현실을 무시하고 자유롭게 창조하고 묘사하라.